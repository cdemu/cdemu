CDEmu Daemon
2.1.1
~~~~~


Table of Contents:
~~~~~~~~~~~~~~~~~~

1. Introduction
2. CDEmu suite overview
3. Requirements
4. Installation and set-up
5. Troubleshooting
6. CDEmu daemon D-BUS interface
7. Device options
8. Debugging
9. Hard-disk images
10. Encrypted images and password supplying
11. System bus vs. session bus
12. Deprecation of running on system bus
13. CDEmu as D-BUS on-demand service (the daemon autostart)
14. Contact information


1. Introduction
~~~~~~~~~~~~~~~

This is CDEmu daemon, the daemon part of the cdemu suite, a free,
GPL CD/DVD-ROM device emulator for linux.

This document describes both the cdemu suite in general, and the
specifics of CDEmu daemon, such as installation quirks, troubleshooting, and
daemon's D-BUS interface.


2. CDEmu suite overview
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The whole cdemu suite is intended as a rewrite of the cdemu kernel module
and userspace utility that was once written by Robert Penz. But instead of
providing only block device and linux uniform CD-ROM driver interface, CDEmu
daemon tries to implement packet command set as specified by MMC-3 and INF-8090,
thus fully emulating an optical storage device.

Main features:
 - full SCSI device emulation: CDEmu daemon attempts to implement MMC-3 packet
     command set, therefore allowing virtual devices to be used not only as
     block devices, but as full SCSI devices. Aside from mounting the device,
     you can use dd on it, use it with CD-player, or even copy the loaded image
     using one of linux's CD-ROM burning utilities.
 - multiple image format support: cdemu utilizes libMirage, an image
     access library, which attempts to provide unified access to various CD-ROM
     image formats (including B6T, CCD, CDI, CUE, ISO, MDS, NRG and TOC)
 - linux HAL support: cdemu devices are properly detected by HAL, thus
     giving you the same benefits as with the real devices; most notable are
     automount and detection in WINE
 - debugging: both CDEmu daemon and underlying libMirage library have debugging
     code that supports changing verbosity of debug messages while daemon is
     running, making it easier to discover and fix problems.

The whole cdemu suite consists of three major components:
 - kernel module
 - daemon
 - clients

2.1. Kernel module
~~~~~~~~~~~~~~~~~~

Kernel module takes care of device emulation in the kernel; it registers virtual
device with appripriate drivers and creates corresponding device nodes. It also
creates a special character device that is used for communication with userspace.

As device is accessed, requests are generated by kernel, which are in fact SCSI
commands. These are passed to userspace daemon via afore-mentioned character
device. Once daemon processes the request, it returns appropriate data and
status to kernel, thus completing the request.

The whole process is very similar to accessing real device, except that requests
are passed to userspace daemon instead to hardware.

Early, experimental versions of cdemu used a module that was called
cdemu-module. This release is based on vhba module, which was written by Chia-I
Wu. Contrary to cdemu-module, which implemented all the interfaces (i.e. block
device, uniform CD-ROM driver, etc.) manually, vhba implements virtual SCSI host
and lets the kernel's SCSI layer do the rest. This approach is cleaner, faster
and more robust.

2.2. Daemon
~~~~~~~~~~~

This is the part that these docs (should) belong to. The daemon receives SCSI
commands from kernel module and processes them, passing the requested data back
to the kernel.

Daemon implements the actual virtual device; one instance per each device
registered by kernel module. It uses libMirage, an image access library that is
part of the cdemu suite, for the image access (e.g. sector reading).

Daemon is controlled through methods that are exposed via D-BUS. It is written
in C and based on GLib (and thus GObjects), but being controlled over D-BUS, it
allows for different clients written in different languages.

2.3. Clients
~~~~~~~~~~~~

Clients are used to control the daemon; examples of the tasks that can be
achieved by using daemon's D-BUS interface are: loading and unloading a device,
checking device(s) status, setting the debug mask, etc.

A client can be written in any language, as long as it has D-BUS bindings; it can
be either a CLI or a GUI application. For illustration, two clients are included
as part of cdemu:
 - cdemu-client: a simple CLI client
 - gcdemu: a Gtk+ based GUI
For more information about these particular clients, consult their documentation.

Should you be interested in writing your own client, there is a section in this
document that describes the daemon's interface, methods and signals.


3. Requirements
~~~~~~~~~~~~~~~

CDEmu daemon has the following software requirements:
 - GLib >= 2.28
 - libao >= 0.8.0

 - libMirage >= 2.1.0 (part of the suite)
 - VHBA module >= 20110915 (part of the suite)


4. Installation and set up
~~~~~~~~~~~~~~~~~~~~~~~~~~

Please read the INSTALL file. Note however that there are some quirks one should
be aware of.

libMirage, which is part of the cdemu suite, is also required. If you
are building and installing it yourself, make sure that its .pc file is visible
to pkg-config utility; if you are using /usr prefix, you should be fine, but in
case /usr/local or something else is used and you haven't set up pkg-config to
look there, you might need to force it to do so.

For example, if libMirage was installed to /usr/local, CMake would have to
be run as this way:

export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig"
mkdir build && cd build
ccmake ..

VHBA module is not a build-time dependency, but it might be a good idea to have
it installed at this point.


The daemon can register its interface on either system or session D-BUS' bus. By
default, session bus is used. To use system bus, use --bus=system when running daemon.

We provide an option to install the daemon as a D-BUS on-demand
service on both buses. For more information, see Section 11.

We use a single libao backend to support CD-audio playback. This allows you to
select from a number of available audio drivers. Valid choices are the driver
names used by libao as well as "default" and "null". CDEmu is usually
configured to use the "default" libao audio driver, which means that the
audio driver specified in libao's config file ("/etc/libao.conf" or "~/.libao")
is used. If "null" is specified, audio is sent to the null driver, essentially
turning off audio playback. For a full list of valid driver names have a look
at the libao documentation, in particular the "libao.conf" manpage.

Also note that most media players on Linux are capable of digital audio
extraction, meaning they can play CD-audio directly without relying on the
"analog" playback capabilities of the virtual optical device. Because of this
it's possible to use the libao "null" driver and still play CDs normally.


5. Troubleshooting (When bad things happen to good people)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Q: I built and installed the module, but I can't insert it ('modprobe vhba'
results in something along the lines of 'FATAL: Module vhba not found.').

A: Try running 'depmod -a' after you have installed the module.


Q: Daemon fails to start with the following message:
    'cdemud: cdemud_daemon_initialize: failed to open control device /dev/vhba_ctl!
     Daemon initialization failed: Failed to open control device.'

A: The message indicates that either vhba module is not inserted or you don't
   have read/write permissions for /dev/vhba_ctl. Please make sure that module
   is inserted, that /dev/vhba_ctl exists and that you have proper read/write
   permissions.


Q: Daemon fails to start with the following message:
    'cdemud: cdemud_daemon_initialize: failed to get name on system bus!
     Daemon initialization failed: Name request on D-BUS failed.'

A: The message indicates that name registration on the system bus has failed.
   In case you are trying to run the daemon on system bus, the most likely cause
   of error are improper permissions. Make sure that CDEmu daemon's D-BUS configuration
   file is in proper place and that you are running the daemon as root.
   If you are trying to run the daemon on session bus, you need to run the daemon
   as the user who owns the (X11) session. Running from Virtual Terminals (VTs) with
   session bus might also fail (depending on your configuration), because by default,
   D-BUS' session bus is tied to the X11 log-in session.

Q: Daemon fails to start with the following message:
   cdemu0: cdemud_audio_initialize: failed to open audio device
   (driver: 'default')!

A: Most likely you will need to specify a working audio driver in libao's config
   file (/etc/libao.conf or ~/.libao).


6. CDEmu daemon D-BUS interface (a.k.a. writing your own client)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Communication between CDEmu daemon and a client is done via D-BUS. CDEmu daemon
registers itself on either sytem or session bus, where it exposes the interface
which can be used by client to control the daemon.

Currently implemented interface version: 5 (since v.2.1.0)


6.1. D-BUS name and object path
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The name CDEmu daemon requests on the system bus is "net.sf.cdemu.CDEmuDaemon",
whereas the object path is "/Daemon". The name of the interface is
"net.sf.cdemu.CDEmuDaemon".

To illustrate, a simple python program connecting to daemon registered on system
bus would therefore look like this:

import dbus
if getattr(dbus, 'version', (0,0,0)) >= (0,41,0):
    import dbus.glib

system_bus = dbus.SystemBus()
dbus_proxy = system_bus.get_object('net.sf.cdemu.CDEmuDaemon', '/Daemon')
dbus_iface = dbus.Interface(dbus_proxy, 'net.sf.cdemu.CDEmuDaemon')

6.2. Methods
~~~~~~~~~~~~

For more information on D-BUS methods, argument direction and signatures or
language-specific data type mappings, please consult the D-BUS documentation.

CDEmu daemon's interface consists of the following methods that can be used to
control the daemon:

* GetDaemonVersion (version)
    + version: out; "s"
        Daemon version string.

    - Returns daemon version string.

* GetLibraryVersion (version)
    + version: out; "s"
        Library version string

    - Returns library version string of libMirage library used by
      the daemon.

* GetDaemonInterfaceVersion (version)
    + version: out; "i"
        Daemon interface version number

    - Returns daemon interface version number, which should be used to detect
      if client can use the interface or not.

* EnumDaemonDebugMasks (type, masks)
    + masks: out; "a(si)"
        Array of structures containing supported debug masks. Each structure
        has two fields; debug mask name (string) and debug mask value (int).

    - Returns debug masks supported by the daemon.

* EnumLibraryDebugMasks (type, masks)
    + masks: out; "a(si)"
        Array of structures containing supported debug masks. Each structure
        has two fields; debug mask name (string) and debug mask value (int).

    - Returns debug masks supported by the libMirage library that is used by
      the daemon.

* EnumSupportedParsers (parsers)
    + parsers: out; "a(ssa(ss))"
        Array of structures containing information about supported parsers.
        Each structure has multiple fields; parser ID (string), parser name
        (string), and array of supported file types, each comprising a file
        type description (string) and image file MIME type
        (string).

    - Returns supported image parsers.

* EnumSupportedWriters (writers)
    + writers: out; "a(sss)"
        Array of structures containing information about supported writers.
        Each structure has multiple fields; writer ID (string), writer name
        (string), and a writer's parameter sheet XML, which describes the
        writer's parameters.

    - Returns supported image writers.

* EnumSupportedFilterStreams (filter_streams)
    + filter_streams: out; "a(ssba(ss))"
        Array of structures containing information about supported filter
        streams. Each structure has multiple fields; filter stream ID
        (string), filter stream name (string), a flag indicating whether
        filter stream supports writing, and an array of supported
        file types, each comprising a file type description (string)
        and file type MIME type (string).

    - Returns supported filter streams.

* GetNumberOfDevices (number_of_devices)
    + number_of_devices: out; "i"
        Number of devices (int).

    - Returns number of virtual devices.

* DeviceGetStatus (device_number, loaded, file_names)
    + device_number: in; "i"
        Device you are requesting status for (int).
    + loaded: out; "b"
        Boolean denoting whether device is loaded or not.
    + file_names: out; "as"
        Image's file name(s) (string). If device is not loaded, an empty array is
        returned.

    - Returns the status of specified device.

* DeviceLoad (device_number, file_names, parameters)
    + device_number: in; "i"
        Device that is to be loaded (int).
    + file_names: in; "as"
        File name(s) of the image to be loaded (array of strings).
    + parameters: in; "a{sv}"
        Additional (optional) parameters, stored in a D-BUS dictionary type. If
        no parameters are needed, empty dictionary should be sent.
        Currently supported parameters:
            - "password":"password_string"; password for encrypted images

    - Attempts to load the image into specified device.
    - The client might wish to detect MIRAGE_E_NEEDPASSWORD error, which
      indicates that the image is encrypted and needs a password provided via
      parameters.

* DeviceUnload (device_number)
    + device_number: in; "i"
        Device that is to be unloaded (int).

    - Attempts to unload the device.

* DeviceGetOption (device_number, option_name, option_values)
    + device_number: in; "i"
        Device for which the specified option's value is to be retrieved (int).
    + option_name: in; "s"
        Name of the option (string).
    + option_values: out; "v"
        Option value (variant). The actual content depends on the option.

    - This method retrieves the value(s) of specified option for specified device.
      For more information on supported options, see Section 7.

* DeviceSetOption (device_number, option_name, option_values)
    + device_number: in; "i"
        Device for which the specified option's value is to be set (int).
    + option_name: in; "s"
        Name of the option (string).
    + option_values: in; "av"
        Option value (variant). The actual content depends on the option.

    - This method sets the value(s) of specified option for specified device.
      For more information on supported options, see Section 7.

6.3. Signals
~~~~~~~~~~~~

In addition to the methods, CDEmu daemon's interface emits the following signals
in response to the change of status of either the daemon or one of the devices:

* DeviceStatusChanged
    + device_number: "i"
        Device that emitted the signal (int).

    - emitted when device is loaded/unloaded

* DeviceOptionChanged
    + device_number: "i"
        Device that emitted the signal (int).
    + option: "s"
        Option that has been changed (string).

    - emitted when device's option is changed

* DeviceMappingReady
    + device_number: "i"
        Device that emitted the signal (int).

    - emitted when the device's mapping to /dev/srX and /dev/sgY are established



Daemon start/stop detection:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Version 1 of the interface had two signals, "DaemonStarted" and "DaemonStopped",
to indicate when the daemon has been started or stopped. In version 2, these have
been removed; clients should instead monitor the "NameOwnerChanged" signal on the
org.freedesktop.DBus interface to detect daemon start/stop.

The daemon registers itself on the bus after all devices have been created so
when the name ownership request is detected, the daemon and devices are ready
for use. At this point devices' mappings are not ready yet; when they become
available, each device emits "DeviceMappingReady" signal.


7. Device options
~~~~~~~~~~~~~~~~~

CDEmu virtual devices have the following options that can be get/set via the
DeviceGetOption/DeviceSetOption API. Please note that number of arguments and
argument types for DeviceSetOption function are strictly checked; i.e. tbe
method call will fail, for example, if argument for the 'dpm-emulation option'
is of type G_TYPE_INT.

* dpm-emulation
   + arguments: enabled (boolean - "b")

   - DPM emulation flag. Determines whether DPM emulation is performed.

* tr-emulation
   + arguments: enabled (boolean - "b")

   - Transfer rate emulation flag. Determines whether transfer rate emulation is
     performed

* bad-sector-emulation
   + arguments: enabled (boolean - "b")

   - Bad sector emulation flag. Determines whether bad sector emulation is
     performed. This involves reading sector's data, computing error detection
     code (EDC) over it, and comparing it to stored EDC; if the two do not
     match, sector is proclaimed as a bad one. Some copy-protection schemes
     rely on this behavior.

* device-id
   + arguments: vendor_id, product_id, revision, vendor_specific  (tuple of strings:  - "(ssss)"

   - Device ID. Determines the device identifier (vendor identifier, product
     identifier, product revision and vendor-specific string) as returned by
     INQUIRY command. Changing the ID might be useful in cases when an
     application doesn't like the default ID for some reason.

   - Note that the length of argument strings should be as following: vendor_id
     8 characters, product_id 16 characters, revision 4 characters and
     vendor_specific 20 characters. The actual arguments can surpass these
     lengths, but only specified amount of characters will actually be used by
     the device.

* daemon-debug-mask
   + arguments: mask (integer - "i")

   - Daemon debug mask. Determines the amount of verbosity of daemon's code.

* library-debug-mask
   + arguments: mask (integer - "i")

   - Library debug mask. Determines the amount of verbosity of libMirage library
     used by the daemon.


8. Debugging
~~~~~~~~~~~~

Both CDEmu daemon and the underlying libMirage contain debugging code that
supports changing the verbosity of debug traces while the daemon is running
and processing requests.

The details of changing the debug mask vary from client to client, but in
general it should be possible to change the debug mask of every device for
either the daemon or the library. Supported masks can be obtained from the
daemon for both components. The actual mask is combination of these masks and
determines which traces get printed and which not.

When daemon is run in non-daemon mode, it prints the traces into console. When
run in daemon mode, system logger (i.e. syslogd) is used.

Using appropriate debug mask and monitoring the output, the source of problem
can be quickly found, be it either a failure in loading an image or incorrect
response to the given command.

If you are debugging the daemon using the GNU Debugger (gdb) and get an error
reading "failed to open control device" then you need to check your permissions.
GDB doesn't honor any set-UID or set-GID flags on the daemon executable so you
will have to make sure that your user has read and write permissions on the
control device.


9. Hard-disk images
~~~~~~~~~~~~~~~~~~~

It possible to use CDEmu to mount certain hard-disk images that are
supported by libMirage. However, hard-disk device emulation is not
implemented, but rather the data is simply laid out in a fashion
according to standard 2048-sector data CD-ROMs. Due to the lack of
block-device access, you may run into some problems when attempting to
mount some images.

The mount command may complain that it could not set a sector size of
512 which is the de-facto standard hard-disk sector size. Mount may
also complain that it was unable to find filesystem signatures, and
therefore refuse to mount the CDEmu device. To work around this, a
loopback device can be used.

Say for instance you have loaded an Apple Disk image (.img.bin) and
Linux will not mount the CDEmu device (for instance /dev/sr1).
You can solve this by loopback mounting the device like so:

mount -t hfsplus -o loop /dev/sr1 /mnt/hfsvolume

where /mnt/hfsvolume is your mountpoint. Alternatively, you can use
the losetup program to achieve the same. Losetup also have some
other neat features like setting the offset and size of the image
or device to mount, so if you know the size and offset of
a partitioned image you could for instance choose to loopback mount
only one single partition. Note that in the case of HFS/HFS+ you can
also specify the partition number to mount via the -o part=# option.


10. Encrypted images and password supplying
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

libMirage offers basic support for encrypted images which is supported by
the CDEmu daemon as well.

Encrypted images require password to decrypt the data. When image loading is
performed in libMirage, the parser detects whether password is required, and if
it is, it issues a callback to obtain it from the user.

The problem is that CDEmu daemon and its clients use synchronous communication,
which means that there is no way to propagate the password request from the
callback back to the client, i.e. by the means of emitting signal from daemon
(because technically, the image loading function is still in progress and the
client is waiting for its return status).

Therefore, if no password is provided via 'parameters' argument of DeviceLoad
method and the image loading requires password, the method will fail and return
error MIRAGE_E_NEEDPASSWORD. In this case, client might want to prompt the user
for password and then call DeviceLoad again, this time with password set in
'parameters' argument. If password is incorrect, the method will fail, returning
error MIRAGE_E_WRONGPASSWORD. Otherwise, the image should be loaded successfully
(provided no other errors occured).

Of course, nothing prevents the client to allow the user to enter password as an
optional argument the first time image is loaded.

DISCLAIMER:
~~~~~~~~~~~
the encrypted images support in CDEmu is not -meant- to be secure. In author's
opinion the formats that provide encryption support offer no real benefit over
other formats and should not be considered for making backups in the first place.
However, every now and then one might come across such an image and in those
cases the ability to simply load them might be useful.

Therefore, the password is sent from clients to daemon in plain string form,
with no real protection. Live with it, or don't use it.


11. System bus vs. session bus
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CDEmu daemon registers a D-BUS interface that can be used by clients to communicate with it;
from the initial release on, the interface could be registered either on system or session bus.

A session bus instance is created for every user session, and is visible only within that session.
On the other hand, there's only one instance of system bus, which is visible system-wide.

This means that when session bus is used, every user can run its own instance of CDEmu daemon, as
long as device number limit of VHBA module is not reached. There can be only one instance of the
daemon running on system bus, but it is visible to all users. Also, a single instance of daemon on
system bus and multiple instances on session busses can be running at the same time.

Note that running on system bus requires special permissions; to this end, CDEmu daemon installs a
D-BUS config file which by default allows root to run daemon on system bus. Session bus requires
no such permissions, but the user running the daemon must have read/write permissions to VHBA
character control device.


12. Deprecation of running on system bus
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Running the daemon on system bus is considered deprecated and should be avoided
for various reasons listed below.

First and foremost, running the CDEmu daemon on the system bus leads to security issues in
multi-user environment; any user with access to the daemon over D-BUS is able to load every single
image on the whole system (assuming the daemon is running as root). Effectively, it is also possible
to check existence of files in folders where the user does not have access (by attempting to load a
file as an image and look at the error).

Additionally, some of the services that CDEmu might (indirectly) depend on, are nowdays run in session
mode as well, and require to be accessed from within the session. One example would be PulseAudio audio
daemon, which is commonly configured to be run in per-session mode and might be use by CDEmu's audio
backend. The other example would be GVFS, which might provide the user access to images stored on remote
filesystems (e.g. via CIFS or SSH).


13. CDEmu as D-BUS on-demand service (the daemon autostart)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

D-BUS offers on-demand startup of services; when a client attempts to contact a service that is not running,
D-BUS can launch that service.

In order to do so, a .service describing the service needs to be placed either into /usr/share/dbus-1/services
(for session bus service autostart) or /usr/share/dbus-1/system-services (for system bus service autostart).

CDEmu daemon provides the .service files for both system and session bus service autostart.
The daemon is launched via wrapper scripts that allow setting of the following parameters: number of devices,
audio driver and log file.

Session bus service autostart:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Session bus service autostart installs the cdemu-daemon-session.service file and the cdemu-daemon-session.sh
wrapper script. The default parameters (2 devices, PulseAudio as audio driver and ~/.cdemu-daemon.log as logfile)
can be overridden by specifying variables NUM_DEVICES, AUDIO_DRIVER and LOG_FILE in ~/.cdemu-daemon config file.

Installation of session bus service autostart can be controlled via SESSION_BUS_SERVICE option in daemon's CMake
script (e.g., by passing -DSESSION_BUS_SERVICE=ON/OFF on command-line). By default, installation is enabled.

System bus service autostart:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

System bus service autostart installs the cdemu-daemon-system.service file and the cdemu-daemon-system.sh
wrapper script. The default parameters (2 devices, no audio driver and /tmp/cdemu-daemon.log as logfile)
can be overridden by specifying variables NUM_DEVICES, AUDIO_DRIVER and LOG_FILE in /etc/sysconfig/cdemu-daemon
config file.

In addition to service file and wrapper script, the D-BUS config file is also installed.

Installation of system bus service autostart can be controlled via SYSTEM_BUS_SERVICE option in daemon's CMake
script (e.g., by passing -DSYSTEM_BUS_SERVICE=ON/OFF on command-line). By default, installation is disabled.

NOTE: if system bus service autostart installation is disabled, the D-BUS config file for running on system
bus is also not installed.


14. Contact information
~~~~~~~~~~~~~~~~~~~~~~

CDEmu project's web page: http://cdemu.sourceforge.net
CDEmu project's mailing list: cdemu-devel@lists.sourceforge.net

Author can be directly contacted via e-mail address listed in AUTHORS file.

